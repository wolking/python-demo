# coding=utf-8
import numpy as np


def use_array(a, id_int):
    """
    使用数组
    :param a:
    :param id_int:
    :return:
    """
    nid = id(a)
    print(nid)
    print(nid == id_int)


def un_copy():
    """
    完全不复制，赋值与引用传递
    :return:
    """

    # 将一个数组变量赋值给另一个变量，两个变量相同
    a = np.arange(6).reshape(2, 3)
    b = a
    print(b is a)  # true

    # 作为函数参数，不发生拷贝
    use_array(a, id(a))


def shadow_copy():
    """
    浅拷贝，一般是数组的切片或视图，与数组共享数据，
    浅拷贝的作用
        1、避免数据复制：当我们需要创建一个与原始数组具有相同数据的新数组对象时，使用浅拷贝可以避免显式地复制数据。
            这节省了时间和内存，特别是对于大型数组来说，避免复制数据可以提高效率。
        2、分而治之的操作：在处理大型数组时，有时候需要将数组分成不同的部分进行并行处理或分析。
            通过浅拷贝，可以创建新的数组对象，每个对象处理数组的不同部分，从而实现并行处理。
        3、视图操作：通过浅拷贝，我们可以创建一个新的数组对象，该对象与原始数组共享相同的数据存储空间。
                这意味着对新数组的修改会同时反映在原始数组上。这种特性允许我们创建数组的视图，
                并在不复制数据的情况下对其进行操作。
        4、函数传递：在调用函数时，参数通常是被传递的对象的引用。使用浅拷贝可以创建原始数组的副本，
            将其传递给函数，以避免对原始数组进行意外修改。这对于要保留原始数组的情况非常有用。
    :return:
    """

    # 视图
    a = np.arange(6)
    print(a)  # [0 1 2 3 4 5]
    v = a.view()
    print(v is a)  # 视图是新的数组，此处为false
    print(v.base is a)  # true

    # 对新数组的修改,会影响原数组
    v[0] = 10  # [10  1  2  3  4  5]
    print(a)
    print(id(v))
    print(id(a))

    # 切片
    # 切片与视图相似，不同的是切片是原数组的子集，而视图是最大的子集，等于原数组自己
    s = a[:3]
    print(s)

    # 对切片的修改也会影响原数组
    s[0] = 9
    print(s)
    print(a)
    print(v)


def deep_copy():
    """
    深拷贝
    通过深拷贝，我们可以：
    1、数据隔离：通过深拷贝，可以创建原始对象的副本，使得新对象与原始对象完全独立，互不影响。
                这对于需要对数据进行修改或处理的情况非常有用，因为它避免了对原始数据的意外修改。
    2、嵌套对象的独立性：如果原始对象包含嵌套的对象或集合（例如列表、字典等），深拷贝可以复制整个嵌套结构，
                    并创建独立的对象副本。这样，无论是修改新对象还是原始对象，都不会相互影响。
    3、对象传递：在函数调用或多线程环境中，使用深拷贝可以确保传递对象的完整性。深拷贝创建了原始对象的独立副本，
                该副本可以被修改而不会影响原始对象。这对于确保数据的一致性和避免竞争条件非常重要。
    4、对象持久化：通过深拷贝可以创建对象的独立副本，这些副本可以用于持久化或保存到文件系统。在这种情况下，
                原始对象与保存的副本是完全独立的，可以单独修改或恢复。
    :return:
    """

    a = np.arange(6)
    print(a)
    b = a.copy()
    print(b)
    # 对b的修改，不会影响原数组
    b[0] = 10
    print(a)
    print(b)

    a = np.array([Ele(10), Ele(11)])
    print(a)
    b = a.copy()
    print(b)
    # 对新数组引用类型元素的修改，会影响原数组
    b[0].d = 1
    print(a)
    print(b)


class Ele:
    def __init__(self, c):
        self.d = c

    def __repr__(self):
        return "{0}_{1}".format(id(self), self.d)


if __name__ == '__main__':
    # 拷贝与复制
    # un_copy()
    # shadow_copy()
    deep_copy()
